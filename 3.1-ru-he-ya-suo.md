# 3.1 如何压缩

以 OP-Rollup 的为例，我们要向 Layer 1 上传一段时间内的所有交易详情，如果不对这部分数据进行高度压缩，那

分担负载的效果就非常小了。我们以单笔交易为例，它身上其实有许多可改进的空间。比如对于一笔常见的转账交

易，它的原数交易数据可能是以下这样的：

**4232f461**000000000000000000000000**7ea2be2df7ba6e54b1a9c70676f668455e329d29**0000000000000

00000000000**d548a5e31de2b4c2681a58a3be5302abcae4bc57**0000000000000000000000000000000000

0000000000000000000000000186a0

（**Method ID** / 填充的 0 / **代币合约地址** / 填充的 0 / **收款的账户地址** / 提币数量）

原始数据有很多可优化的空间：

1. 用**科学计数法** <sup>[1]</sup> 把转账数量压缩成 64 位数据，并删除不必要的 0 。（数量的精度会略微下降，但实践中影响不大）
2. 调用的方法如果很常见，可以删除所调用的 Method ID ，因为如“转账一笔 ERC20 <sup>[2]</sup> 代币”的交易，可以通过交易内容的特征推测
3. 常用行为设置绿色通道（ Helper ID ）：大部分发送代币的行为都是如 USDC、WETH 等常用代币，可以用更短的 Helper ID 表示如“ 发送 USDC ”的信息
4. 登记一个“电话簿”，纪录收款人地址，将 40 位的地址压缩为第 XXX 页的第 X 个地址。
5. 如果发送的是 ETH，连 Helper ID 都可以省掉。

最终我们需要上传至 Layer 1 的数据变为了：

**059c57**0186a0

（**收款账户“电话簿”编号** / 提币数量）

 <CompressText />

除了以上手段以外，**还有进一步压缩的空间吗**？

## 注释及拓展阅读

<sup>[1]</sup> 科学记数法是一种记数的方法。 把一个数表示成 a 与 10 的 n 次幂相乘的形式（1 ≤ |a| < 10 ，a 不为分数，n 为整数），这种记数法叫做科学记数法。 如 19971400000000 表示为 1.99714 × 10<sup>13</sup>。。

<sup>[2]</sup> ERC20 是第 20 号以太坊改进提案（Ethereum Request for Comments 即“以太坊征求意见”）。ERC20 是最常见的代币标准之一，规定了代币名、精度、授权额度等标准。如 USDC 、 WETH 、 WBTC 等都是 ERC20 代币。
